---
title: "Using the PokeAPI"
author: "Maxwell Marion-Spencer"
date: '2022-06-26'
output: html_document:
  toc: true
---

# Requirements

List of requirements:

- `tidyverse`
- `httr`
- `jsonlite`

```{r, include = FALSE}
library(tidyverse)
library(jsonlite)
library(httr)
```


This vignette will highlight some of the many features of the [PokeAPI](https://pokeapi.co/), while also providing a few funtions that may be useful for pulling and analysing data. 




# Functions

## Function: pokemon


```{r}
# Building 'Pokemon' Query function
pokemon <- function(pokemon, stats = TRUE){
  
  ###
  # Pulls in height, weight, type and base stats (hp, attack, defense, 
  #  special attack, special defense, speed)
  ###
  
  # Fixing case
  pokemon <- tolower(pokemon)
  
  # Getting API output
  output <- fromJSON(paste0('https://pokeapi.co/api/v2/pokemon/',pokemon,collapse =","))
  
  # Output if user DOES want to see the battle stat attributes of the pokemon
  if(stats == TRUE){
    
  # Loading the data into a vector
  output_row <- c(pokemon,  output$types$type$name[1], output$types$type$name[2],output$height,output$weight,      output$stats$base_stat[1],output$stats$base_stat[2],output$stats$base_stat[3],output$stats$base_stat[4],output$stats$base_stat[5],output$stats$base_stat[6])
  
  # Coercing into a data frame
  output_frame <- as.data.frame(t(output_row))
  colnames(output_frame) <- c("name","type_1","type_2","height","weight","hp","attack","defense","spec_attack","spec_defense","speed")
  
  # Making the numeric variables properly numeric
  output_frame <- transform(output_frame, height = as.numeric(height),weight = as.numeric(weight),hp = as.numeric(hp), attack = as.numeric(attack), defense = as.numeric(defense), spec_attack = as.numeric(spec_attack),spec_defense = as.numeric(spec_defense), speed = as.numeric(speed))
  
  # Returning a nice data frame
  return(output_frame)
  }
  
  # Output if user does NOT want to see the battle stat attributes of the pokemon
  if(stats == FALSE){
    
  # Loading the data into a vector
  output_row <- c(pokemon, output$types$type$name[1], output$types$type$name[2], output$height, output$weight)
  
  # Coercing into a data frame
  output_frame <- as.data.frame(t(output_row))
  colnames(output_frame) <- c("name","type_1","type_2","height","weight")
  
  # Making the numeric variables properly numeric
  output_frame <- transform(output_frame, height = as.numeric(height), weight = as.numeric(weight))
  
  # Returning a nice data frame
  return(output_frame)
  }
}
```


## Function: pokemon_df

```{r}
# Building a function for pokemon that allows you to pull a df
pokemon_df <- function(all = FALSE, last = NULL){
  
  ###
  # Pulls in height, weight, type and base stats (hp, attack, defense, 
  #  special attack, special defense, speed) for up to a specific pokemon, 
  #  or all pokemon. Note that 'last' can be entered as a number, or as a 
  #  specific pokemon.
  ###
  
  # Fixing case, if last is entered as a specific pokemon
  if(is.character(last) == TRUE){
    last <- tolower(last)
  }
  
  # Accounting for the user entering a specifc pokemon rather than a numeric id
  if(is.numeric(last) == FALSE){
    last_test <- fromJSON(paste0('https://pokeapi.co/api/v2/pokemon/',last,collapse =","))
    last <- last_test$id
  }
  
  # If all = TRUE, returning a df of all pokemon from Generation 1 + 2 (to 251)
  # NOTE: This is done to limit the burden on the APi
  if(all == TRUE){
    last <- 251
  }
  
  # Establishing empty df to merge things to
  output_df <- rep("a",11)
  
  # Running for loop to populate df
  for(n in 1:last){
  
    # Getting API output
    output <- fromJSON(paste0('https://pokeapi.co/api/v2/pokemon/',n,collapse =","))
    
    # Loading the data into a vector
    output_row <- c(output$name,  output$types$type$name[1], output$types$type$name[2],output$height,output$weight,         output$stats$base_stat[1],output$stats$base_stat[2],output$stats$base_stat[3],output$stats$base_stat[4],output$stats$base_stat[5],output$stats$base_stat[6])
  
    # Coercing into a data frame
    output_frame <- as.data.frame(t(output_row))
    colnames(output_frame) <- c("name","type_1","type_2","height","weight","hp","attack","defense","spec_attack","spec_defense","speed")
  
  # Adding the stats to the output df
  output_df <- rbind(output_df,output_frame)
  
  }
  
  # Making the numeric variables properly numeric
  output_df <- transform(output_df, height = as.numeric(height),
                              weight = as.numeric(weight),hp = as.numeric(hp),
                              attack = as.numeric(attack), 
                              defense = as.numeric(defense), 
                              spec_attack = as.numeric(spec_attack),
                              spec_defense = as.numeric(spec_defense), 
                              speed = as.numeric(speed))
  
  # Fixing row names and removing extraneous 'starter' row
  output_df <- output_df[-1,]
  rownames(output_df) <- NULL
  
  # Returning our desired data frame
  return(output_df)
  
}
```


```{r}
#Running pokemon_df on all to save for EDA
all_pokemon <- pokemon_df(all = TRUE)
```


## Function: habitat

```{r}
habitat <- function(habitat){
  ###
  # Asks for habitat as an argument, returns a data frame of the pokemon who can
  # be found in that habitat.
  # 
  # NOTE: Habitats are: cave, forest, grassland, mountain, rare, rough-terrain,
  # sea, urban, and waters-edge.
  ###
  
  # Establishing a habitat list for input checking
  habitat_list <- c("cave", "forest", "grassland", "mountain", "rare", 
                    "rough-terrain", "sea", "urban", "waters-edge")
  
  # Implementing a check and error message
  if(!(habitat %in% habitat_list)){
    stop("Please pick one of cave, forest, grassland, mountain, rare, 
    rough-terrain, sea, urban, or waters-edge.")
  }
  
  # Building output
  output <- fromJSON(paste0('https://pokeapi.co/api/v2/pokemon-habitat/',habitat,collapse =","))
  
  # Building output df and naming
  output_df <- data.frame(output$pokemon_species$name)
  colnames(output_df) <- c(habitat)
  
  # Returning results
  return(output_df)
}
```


## Function: color

```{r}
color <- function(color){
  ###
  # Asks for color as an argument, returns a data frame of all pokemon of that
  # color.
  #
  # NOTE: Colors are - black, blue, brown, gray, green, pink, purple, red, white
  # and yellow.
  ###
  
  # Establishing a color list for input checking
  color_list <- c("black","blue","brown","gray","grey","green","pink", 
                  "purple","red","white","yellow")
  
  # Implementing a check and error message
  if(!(color %in% color_list)){
    stop("Please pick one of black, blue, brown, gray, green, pink, purple, red,
    white, or yellow ")
  }
  
  # Troubleshooting grey != gray
  if(color == 'grey'){
    color <- 'gray'
  }
  
  # Building output
  output <- fromJSON(paste0('https://pokeapi.co/api/v2/pokemon-color/',color,collapse =","))
  
  # Establishing empty df
  #output_df <- as.data.frame(output$)
  
  #for(i in 1:length(output$pokemon_species$name)){
     #output_df <- as.data.frame(color, output$pokemon_species$name[i])
  
  output_df <- data.frame(output$pokemon_species$name)
  colnames(output_df) <- c(color)
  return(output_df)
}
```


## Function: berry

```{r}
berry <- function(all = NULL, berry = NULL){
  ###
  # Asks for berry as an argument, returns growth_time, max_harvest, size,
  # smoothness, soil_dryness, firmness, and flavor
  #
  # NOTE: The berries are: cheri, chesto, pecha, rawst, aspear, leppa, oran, 
  # persim, lum, sitrus, figy, wiki, mago, aguav, iapapa, razz, bluk, nanab,
  # wepear, pinap
  ###
  
  # Building index df to convert user input into numeric 
  index <- rep(1:20)
  berry_list <- c("cheri", "chesto", "pecha", "rawst", "aspear", "leppa", "oran",
                  "persim", "lum", "sitrus", "figy", "wiki", "mago", "aguav",
                  "iapapa", "razz", "bluk", "nanab", "wepear", "pinap")
  index_df <- data.frame(berry_list, index)
  
  # Switching berry user input to a number if necessary
  if(is.numeric(berry) == FALSE){
    berry <- which(index_df$berry_list == berry)
  }
  
  # If user selects all berries
  if(all == TRUE){
  
    # Establishing empty df to merge things to
    output_df <- rep("a",12)
  
    for(n in 1:20){
      
      # Getting API output
      output <- fromJSON(paste0('https://pokeapi.co/api/v2/berry/',n,collapse =","))
    
      # Loading the data into a vector
      output_row <- c(output$name, output$growth_time, output$max_harvest, output$size, 
                  output$smoothness, output$soil_dryness, output$firmness$name,
                  output$flavors$potency[1], output$flavors$potency[2],
                  output$flavors$potency[3], output$flavors$potency[4],
                  output$flavors$potency[5])
  
      # Coercing into a data frame
      output_frame <- as.data.frame(t(output_row))
      colnames(output_frame) <- c("name", "growth_time", "max_harvest", "size", "smoothness", 
                    "soil_dryness", "firmness", "spicy","dry","sweet","bitter",
                    "sour")
  
      # Adding the stats to the output df
      output_df <- rbind(output_df,output_frame)
      
    }
    
      # Fixing row names and removing extraneous 'starter' row
      output_df <- output_df[-1,]
      rownames(output_df) <- NULL
      
      
      # Fixing types of df
      output_df <- transform(output_df, growth_time = as.numeric(growth_time),
                             max_harvest = as.numeric(max_harvest), size = as.numeric(size),
                             smoothness = as.numeric(smoothness), soil_dryness = as.numeric(soil_dryness),
                             spicy = as.numeric(spicy), dry = as.numeric(dry),
                             sweet = as.numeric(sweet), bitter = as.numeric(bitter),
                             sour = as.numeric(sour))
  
      # Setting firmness as a factor
      output_df$firmness <- as.factor(output_df$firmness)
      levels(output_df$firmness) <- c('very-soft','soft','hard','very-hard','super-hard')
      
      
      # Returning our desired data frame
      return(output_df)
  }
  
  # Building single output
  output <- fromJSON(paste0('https://pokeapi.co/api/v2/berry/',berry,collapse =","))
  
  output_row <- c(output$name, output$growth_time, output$max_harvest, output$size, 
                  output$smoothness, output$soil_dryness, output$firmness$name,
                  output$flavors$potency[1], output$flavors$potency[2],
                  output$flavors$potency[3], output$flavors$potency[4],
                  output$flavors$potency[5])
  
  output_names <- c("name", "growth_time", "max_harvest", "size", "smoothness", 
                    "soil_dryness", "firmness", "spicy","dry","sweet","bitter",
                    "sour")
  
  output_df <- as.data.frame(output_row, output_names)
  
  # Fixing types of df
  output_df <- transform(output_df, growth_time = as.numeric(growth_time),
                 max_harvest = as.numeric(max_harvest), size = as.numeric(size),
                 smoothness = as.numeric(smoothness), soil_dryness = as.numeric(soil_dryness),
                 spicy = as.numeric(spicy), dry = as.numeric(dry),
                 sweet = as.numeric(sweet), bitter = as.numeric(bitter), 
                 sour = as.numeric(sour))
  
  # Setting firmness as a factor
  output_df$firmness <- as.factor(output_df$firmness)
  levels(output_df$firmness) <- c('very-soft','soft','hard','very-hard','super-hard')
  
  colnames(output_df) <- output$name
  
  return(output_df)

}
```


## Function: egg_group

```{r}
egg_group <- function(group){
  ###
  # Asks for egg group as an argument and returns all pokemon from that egg 
  # group
  #
  # NOTE: The egg groups are: monster, water1, bug, flying, ground, fairy, plant,
  #       humanshape, water3, mineral, indeterminate, water2, ditto, dragon, 
  #       and no-eggs
  ###
  
  # Establishing a group list for input checking
  egg_list <- c("monster", "water1", "bug", "flying", "ground", "fairy", "plant",
        "humanshape", "water3", "mineral", "indeterminate", "water2", "ditto",
        "dragon", "no-eggs")
  
  # Implementing a check and error message
  if(!(group %in% egg_list)){
    stop("Please pick one of: monster, water1, bug, flying, ground, fairy, plant,
         humanshape, water3, mineral, indeterminate, water2, ditto, dragon, 
         or no-eggs")
  }
  
  # Building output
  output <- fromJSON(paste0('https://pokeapi.co/api/v2/egg-group/',group,collapse =","))
  
  # Correcting output
  output_df <- data.frame(output$pokemon_species$name)
  colnames(output_df) <- c(output$name)
  
  # Returning output_df
  return(output_df)
  
}
```


```{r}
# Creating all berry df for EDA
all_berry <- berry(all = TRUE)
#all_berry
```


## Exploratory Data Analysis

– You should pull data from at least two endpoints (possibly combining them into one)
– You should create one new variable that is a function of the variables from a data set you use

– You should create some contingency tables
– You should create numerical summaries for some quantitative variables at each setting of some of your categorical variables
– You should create at least five plots utilizing coloring, grouping, etc. All plots should have nice labels and titles.
∗ You should have at least one bar plot, one histogram, one box plot, and one scatter plot

```{r}
# A one-way contigency table for primary type of Generation I and Generation II pokemon
all_pokemon %>% group_by(type_1) %>% 
  summarize(n())
```
```{r}
# A table for secondary types of pokemon
all_pokemon %>% group_by(type_2) %>% 
  summarize(n())
```

```{r}
types_table <- addmargins(table(all_pokemon$type_1, all_pokemon$type_2))
types_table
```

```{r}
# One way table of the frequency of pokemon's height
table(as.numeric(all_pokemon$height))
```

```{r}
# Numerical summary for average weight of pokemon by type, creating a
#new variable for 'BMI"
all_pokemon %>% group_by(type_1) %>% select(type_1, weight, height) %>% 
  mutate(bmi = weight/(height^2)) %>%
  summarise(AvgWeight = mean(weight), SdWeight = sd(weight), 
            MedianWeight = median(weight),AvgHeight = mean(height),
            SdHeight = sd(height), MedianHeight = median(height),
            AvgBMI = mean(bmi), SdBMI = sd(bmi), MedianBMI = median(bmi))
```


```{r}
# Numerical summary for average weight of pokemon by type_1 and type_2
all_pokemon %>% group_by(type_1) %>% 
  summarise(AvgWeight = mean(weight), AvgHeight = mean(weight), 
            AvgAttack = mean(attack), AvgDefense = mean(defense),
            AvgSpecAttack = mean(spec_attack), 
            AvgSpecDefense = mean(spec_defense), 
            AvgSpeed = mean(speed))
```

Bar Plot

```{r}
type_bar <- ggplot(data = all_pokemon, aes( x = type_1))
type_bar + geom_bar(aes(fill = type_2), position = "dodge") + xlab("1st Type") + ylab("Count") + labs(title = "Barplot of a Pokemon's Primary Type by Secondary Type") +
  scale_fill_discrete(name = "2nd Type") + theme(axis.text.x = element_text(angle = 45))
```


Histogram

```{r}
type_hist <- ggplot(data = all_pokemon, aes(x = weight))
type_hist + geom_histogram(fill = "red") + labs(title = "Histogram of Pokemon Weight\n(Pokemon no.1-251)") +
  xlab("Weight") + ylab("Count")
```


Box Plot

```{r}
# Creating plotting item and generating BMI
bmi_df <- all_pokemon %>% select(name, type_1, weight, height) %>% 
  mutate(bmi = weight/(height^2)) %>% mutate(gen = NA)

# Establishing gen values
bmi_df$gen[1:151] <- "1"
bmi_df$gen[152:251] <- "2"

bmi_box <- ggplot(bmi_df, aes(x = gen, y = bmi))
bmi_box + geom_boxplot() + geom_jitter(aes(color = type_1), width = 0.3) + 
  labs(title = "Boxplot of Pokemon BMI by Generation\n(Gen. 1 and 2)",
       x = "Generation", y = "BMI", color = "Primary Type")


```


Scatter Plot

```{r}
pokemon_scatter <- ggplot(all_pokemon, aes(x = weight, y = height))
pokemon_scatter + geom_point(aes(color = type_1)) + geom_smooth(method = lm) +
  labs(title = "Relationship between Weight and Height of Pokemon\n(Gen. 1 and 2)",
       x = 'Weight', y = 'Height', 
       color = 'Primary Type')
```

Berry Analysis

```{r}
berry_scatter <- ggplot(all_berry, aes(x = size, y = growth_time))
berry_scatter + geom_point(aes(color = firmness)) + geom_smooth(method = lm) +
  labs(title = "Association between Size and Growth Time of Berries", x = 'Size', y = 'Growth Time', color = 'Firmness')

levels(all_berry$firmness)
```

```{r}
# Berry taste profile summary data
all_berry %>% select(spicy,dry,sweet,bitter,sour) %>% 
  summarise(AvgSpice = mean(spicy), AvgDryness = mean(dry), 
            AvgSweet = mean(sweet), AvgBitter = mean(bitter), 
            AvgSour = mean(sour))
```



## Conclusion








